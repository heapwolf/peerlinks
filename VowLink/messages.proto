syntax = "proto3";
package proto;

//
// Network
//

message Hello {
  int32 version = 1;
  int32 rate_limit = 2; // maximum number of messages per hour
  bytes nonce = 3; // encryption nonce
}

message Link {
  message TBS {
    bytes trustee_pub_key = 1;
    double expiration = 2;

    // NOTE: This MUST be filled either by sender/recipient before
    // generating/verifying the signature below.
    bytes channel_id = 3;
  }

  TBS tbs = 1;
  bytes signature = 2;
}

message Invite {
  bytes channel_pub_key = 1;
  string channel_name = 2;
  ChannelMessage channel_root = 3;

  repeated Link links = 4;
}

message EncryptedInvite {
  bytes box = 1;
}

message LinkRequest {
  string peer_id = 1;
  bytes trustee_pub_key = 2;
  bytes box_pub_key = 3;
}

message ChannelMessage {
  message Root {
  }

  message Text {
    string text = 1;
  }

  message Body {
    oneof body {
      Root root = 1;
      Text text = 2;
    }
  }

  message Content {
    message TBS {
      repeated Link chain = 1;
      double timestamp = 2;
      Body body = 3;

      // NOTE: Despite these fields being outside of content they have to be
      // included here to prevent replay attacks
      repeated bytes parents = 4;
      uint64 height = 5;
    }

    // Link chain that leads from the channel's public key to the signer of
    // this message
    repeated Link chain = 1;

    // Floating point unix time
    double timestamp = 2;

    // body of the message
    Body body = 3;

    bytes signature = 4;
  }

  bytes channel_id = 1;

  // NOTE: can be empty only in the root message
  repeated bytes parents = 2;

  // height = max(p.height for p in parents)
  uint64 height = 3;

  // NOTE: encryption key = HASH(channelPubKey, 'vowlink-symmetric')
  bytes encrypted_content = 4;
}

message Query {
  bytes channel_id = 1;
  uint64 min_height = 2;
  bytes cursor = 3;
  uint32 limit = 4;
}

message QueryResponse {
  bytes channel_id = 1;
  repeated ChannelMessage messages = 2;
  bytes forward_cursor = 3;
  bytes backward_cursor = 4;
  uint64 min_leaf_height = 5;
}

message Error {
  string reason = 1;
}

message Packet {
  oneof content {
    EncryptedInvite invite = 1;
    ChannelMessage message = 2;
    Error error = 3;

    Query query = 4;
    QueryResponse query_response = 5;
  }
}

//
// Storage
//

message Identity {
  message ChannelChain {
    bytes channel_id = 1;
    repeated Link links = 2;
  }

  bytes public_key = 1;
  bytes secret_key = 2;

  repeated ChannelChain channel_chains = 3;
}

message Channel {
  bytes public_key = 1;
  string name = 2;
  ChannelMessage root = 3;

  // XXX(indutny): this is a temporary solution. Use Core Data like a real iOS
  // developer.
  repeated ChannelMessage messages = 4;
}

message ChannelList {
  repeated Channel channels = 1;
}
